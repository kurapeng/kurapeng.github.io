<!DOCTYPE html>
<html lang="en">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="Kura Peng">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Kura Peng">
    
    <meta name="keywords" content="42,Kura Peng,Silicon Valley">
    
    <meta name="description" content="">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <title>Tree_Data_Structure_Note · Kura Peng</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        height: 40vh;
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon.png" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Kura Peng&#39;s Website</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">Tree_Data_Structure_Note</a>
            </div>
    </div>
    
    <a class="home-link" href=/>Kura Peng's Website</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:30vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            Tree_Data_Structure_Note
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "Data-Structure Note">Data-Structure Note</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">1.6k</span>Reading time: <span class="post-count reading-time">10 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2018/10/14</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h1><hr>
<h2 id="LCA-Lowest-Common-Ancestor-In-a-Binary-Tree"><a href="#LCA-Lowest-Common-Ancestor-In-a-Binary-Tree" class="headerlink" title="LCA(Lowest Common Ancestor) In a Binary Tree"></a>LCA(Lowest Common Ancestor) In a Binary Tree</h2><h3 id="Method-1-By-Storing-root-to-n1-and-root-to-n2-paths"><a href="#Method-1-By-Storing-root-to-n1-and-root-to-n2-paths" class="headerlink" title="Method 1 (By Storing root to n1 and root to n2 paths):"></a>Method 1 (By Storing root to n1 and root to n2 paths):</h3><p>Following is simple O(n) algorithm to find LCA of n1 and n2.<br>1) Find path from root to n1 and store it in a vector or array.<br>2) Find path from root to n2 and store it in another vector or array.<br>3) Traverse both paths till the values in arrays are same. Return the common element just before the mismatch.</p>
<p>Following is the implementation of above algorithm.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Program for Lowest Common Ancestor in a Binary Tree </span></span><br><span class="line"><span class="comment">// A O(n) solution to find LCA of two given values n1 and n2 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A Binary Tree node </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> key; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>, *<span class="title">right</span>;</span> </span><br><span class="line">&#125;; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Utility function creates a new binary tree node with given key </span></span><br><span class="line"><span class="function">Node * <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Node *temp = <span class="keyword">new</span> Node; </span><br><span class="line">    temp-&gt;key = k; </span><br><span class="line">    temp-&gt;left = temp-&gt;right = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">return</span> temp; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Finds the path from root node to given root of the tree, Stores the </span></span><br><span class="line"><span class="comment">// path in a vector path[], returns true if path exists otherwise false </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findPath</span><span class="params">(Node *root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// base case </span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Store this node in path vector. The node will be removed if </span></span><br><span class="line">    <span class="comment">// not in path from root to k </span></span><br><span class="line">    path.push_back(root-&gt;key); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// See if the k is same as root's key </span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == k) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Check if k is found in left or right sub-tree </span></span><br><span class="line">    <span class="keyword">if</span> ( (root-&gt;left &amp;&amp; findPath(root-&gt;left, path, k)) || </span><br><span class="line">         (root-&gt;right &amp;&amp; findPath(root-&gt;right, path, k)) ) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If not present in subtree rooted with root, remove root from </span></span><br><span class="line">    <span class="comment">// path[] and return false </span></span><br><span class="line">    path.pop_back(); </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Returns LCA if node n1, n2 are present in the given binary tree, </span></span><br><span class="line"><span class="comment">// otherwise return -1 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLCA</span><span class="params">(Node *root, <span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// to store paths to n1 and n2 from the root </span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path1, path2; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Find paths from root to n1 and root to n1. If either n1 or n2 </span></span><br><span class="line">    <span class="comment">// is not present, return -1 </span></span><br><span class="line">    <span class="keyword">if</span> ( !findPath(root, path1, n1) || !findPath(root, path2, n2)) </span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Compare the paths to get the first different value */</span></span><br><span class="line">    <span class="keyword">int</span> i; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; path1.size() &amp;&amp; i &lt; path2.size() ; i++) </span><br><span class="line">        <span class="keyword">if</span> (path1[i] != path2[i]) </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">    <span class="keyword">return</span> path1[i<span class="number">-1</span>]; <span class="comment">//i increments at the end of for loop.</span></span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Driver program to test above functions </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Let us create the Binary Tree shown in above diagram. </span></span><br><span class="line">    Node * root = newNode(<span class="number">1</span>); </span><br><span class="line">    root-&gt;left = newNode(<span class="number">2</span>); </span><br><span class="line">    root-&gt;right = newNode(<span class="number">3</span>); </span><br><span class="line">    root-&gt;left-&gt;left = newNode(<span class="number">4</span>); </span><br><span class="line">    root-&gt;left-&gt;right = newNode(<span class="number">5</span>); </span><br><span class="line">    root-&gt;right-&gt;left = newNode(<span class="number">6</span>); </span><br><span class="line">    root-&gt;right-&gt;right = newNode(<span class="number">7</span>); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"LCA(4, 5) = "</span> &lt;&lt; findLCA(root, <span class="number">4</span>, <span class="number">5</span>); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"nLCA(4, 6) = "</span> &lt;&lt; findLCA(root, <span class="number">4</span>, <span class="number">6</span>); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"nLCA(3, 4) = "</span> &lt;&lt; findLCA(root, <span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"nLCA(2, 4) = "</span> &lt;&lt; findLCA(root, <span class="number">2</span>, <span class="number">4</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Output:<br>LCA(4, 5) = 2<br>LCA(4, 6) = 1<br>LCA(3, 4) = 1<br>LCA(2, 4) = 2 </p>
<blockquote>
<p>Time Complexity: Time complexity of the above solution is O(n). The tree is traversed twice, and then path arrays are compared.</p>
</blockquote>
<blockquote>
<p>Method 2 (Using Single Traversal)<br>The method 1 finds LCA in O(n) time, but requires three tree traversals plus extra spaces for path arrays. If we assume that the keys n1 and n2 are present in Binary Tree, we can find LCA using single traversal of Binary Tree and without extra storage for path arrays.<br>The idea is to traverse the tree starting from root. If any of the given keys (n1 and n2) matches with root, then root is LCA (assuming that both keys are present). If root doesn’t match with any of the keys, we recur for left and right subtree. The node which has one key present in its left subtree and the other key present in right subtree is the LCA. If both keys lie in left subtree, then left subtree has LCA also, otherwise LCA lies in right subtree.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* C++ Program to find LCA of n1 and n2 using one traversal of Binary Tree */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A Binary Tree Node </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>, *<span class="title">right</span>;</span> </span><br><span class="line">    <span class="keyword">int</span> key; </span><br><span class="line">&#125;; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Utility function to create a new tree Node </span></span><br><span class="line"><span class="function">Node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Node *temp = <span class="keyword">new</span> Node; </span><br><span class="line">    temp-&gt;key = key; </span><br><span class="line">    temp-&gt;left = temp-&gt;right = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">return</span> temp; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// This function returns pointer to LCA of two given values n1 and n2. </span></span><br><span class="line"><span class="comment">// This function assumes that n1 and n2 are present in Binary Tree </span></span><br><span class="line"><span class="function">struct Node *<span class="title">findLCA</span><span class="params">(struct Node* root, <span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Base case </span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If either n1 or n2 matches with root's key, report </span></span><br><span class="line">    <span class="comment">// the presence by returning root (Note that if a key is </span></span><br><span class="line">    <span class="comment">// ancestor of other, then the ancestor key becomes LCA </span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == n1 || root-&gt;key == n2) </span><br><span class="line">        <span class="keyword">return</span> root; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Look for keys in left and right subtrees </span></span><br><span class="line">    Node *left_lca  = findLCA(root-&gt;left, n1, n2); </span><br><span class="line">    Node *right_lca = findLCA(root-&gt;right, n1, n2); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If both of the above calls return Non-NULL, then one key </span></span><br><span class="line">    <span class="comment">// is present in once subtree and other is present in other, </span></span><br><span class="line">    <span class="comment">// So this node is the LCA </span></span><br><span class="line">    <span class="keyword">if</span> (left_lca &amp;&amp; right_lca)  <span class="keyword">return</span> root; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Otherwise check if left subtree or right subtree is LCA </span></span><br><span class="line">    <span class="keyword">return</span> (left_lca != <span class="literal">NULL</span>)? left_lca: right_lca; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Driver program to test above functions </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Let us create binary tree given in the above example </span></span><br><span class="line">    Node * root = newNode(<span class="number">1</span>); </span><br><span class="line">    root-&gt;left = newNode(<span class="number">2</span>); </span><br><span class="line">    root-&gt;right = newNode(<span class="number">3</span>); </span><br><span class="line">    root-&gt;left-&gt;left = newNode(<span class="number">4</span>); </span><br><span class="line">    root-&gt;left-&gt;right = newNode(<span class="number">5</span>); </span><br><span class="line">    root-&gt;right-&gt;left = newNode(<span class="number">6</span>); </span><br><span class="line">    root-&gt;right-&gt;right = newNode(<span class="number">7</span>); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"LCA(4, 5) = "</span> &lt;&lt; findLCA(root, <span class="number">4</span>, <span class="number">5</span>)-&gt;key; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"nLCA(4, 6) = "</span> &lt;&lt; findLCA(root, <span class="number">4</span>, <span class="number">6</span>)-&gt;key; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"nLCA(3, 4) = "</span> &lt;&lt; findLCA(root, <span class="number">3</span>, <span class="number">4</span>)-&gt;key; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"nLCA(2, 4) = "</span> &lt;&lt; findLCA(root, <span class="number">2</span>, <span class="number">4</span>)-&gt;key; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="LCA-For-BST"><a href="#LCA-For-BST" class="headerlink" title="LCA For BST"></a>LCA For BST</h1><blockquote>
<p>If we are given a BST where every node has parent pointer, then LCA can be easily determined by traversing up using parent pointer and printing the first intersecting node.</p>
</blockquote>
<blockquote>
<p>We can solve this problem using BST properties. We can recursively traverse the BST from root. The main idea of the solution is, while traversing from top to bottom, the first node n we encounter with value between n1 and n2, i.e., n1 &lt; n &lt; n2 or same as one of the n1 or n2, is LCA of n1 and n2 (assuming that n1 &lt; n2). So just recursively traverse the BST in, if node’s value is greater than both n1 and n2 then our LCA lies in left side of the node, if it’s is smaller than both n1 and n2, then LCA lies on right side. Otherwise root is LCA (assuming that both n1 and n2 are present in BST)</p>
</blockquote>
<h2 id="recursive-solution"><a href="#recursive-solution" class="headerlink" title="recursive solution:"></a>recursive solution:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A recursive C program to find LCA of two nodes n1 and n2. </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> data; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">left</span>, *<span class="title">right</span>;</span> </span><br><span class="line">&#125;; </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Function to find LCA of n1 and n2. The function assumes that both </span></span><br><span class="line"><span class="comment">   n1 and n2 are present in BST */</span></span><br><span class="line"><span class="function">struct node *<span class="title">lca</span><span class="params">(struct node* root, <span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If both n1 and n2 are smaller than root, then LCA lies in left </span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data &gt; n1 &amp;&amp; root-&gt;data &gt; n2) </span><br><span class="line">        <span class="keyword">return</span> lca(root-&gt;left, n1, n2); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If both n1 and n2 are greater than root, then LCA lies in right </span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data &lt; n1 &amp;&amp; root-&gt;data &lt; n2) </span><br><span class="line">        <span class="keyword">return</span> lca(root-&gt;right, n1, n2); </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> root; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Helper function that allocates a new node with the given data.*/</span></span><br><span class="line"><span class="function">struct node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> data)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">node</span> = (<span class="title">struct</span> <span class="title">node</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">node</span>));</span> </span><br><span class="line">    node-&gt;data  = data; </span><br><span class="line">    node-&gt;left  = node-&gt;right = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">return</span>(node); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Driver program to test lca() */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Let us construct the BST shown in the above figure </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">root</span>        = <span class="title">newNode</span>(20);</span> </span><br><span class="line">    root-&gt;left               = newNode(<span class="number">8</span>); </span><br><span class="line">    root-&gt;right              = newNode(<span class="number">22</span>); </span><br><span class="line">    root-&gt;left-&gt;left         = newNode(<span class="number">4</span>); </span><br><span class="line">    root-&gt;left-&gt;right        = newNode(<span class="number">12</span>); </span><br><span class="line">    root-&gt;left-&gt;right-&gt;left  = newNode(<span class="number">10</span>); </span><br><span class="line">    root-&gt;left-&gt;right-&gt;right = newNode(<span class="number">14</span>); </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">10</span>, n2 = <span class="number">14</span>; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">t</span> = <span class="title">lca</span>(<span class="title">root</span>, <span class="title">n1</span>, <span class="title">n2</span>);</span> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"LCA of %d and %d is %d \n"</span>, n1, n2, t-&gt;data); </span><br><span class="line">  </span><br><span class="line">    n1 = <span class="number">14</span>, n2 = <span class="number">8</span>; </span><br><span class="line">    t = lca(root, n1, n2); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"LCA of %d and %d is %d \n"</span>, n1, n2, t-&gt;data); </span><br><span class="line">  </span><br><span class="line">    n1 = <span class="number">10</span>, n2 = <span class="number">22</span>; </span><br><span class="line">    t = lca(root, n1, n2); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"LCA of %d and %d is %d \n"</span>, n1, n2, t-&gt;data); </span><br><span class="line">  </span><br><span class="line">    getchar(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="iterative-solution"><a href="#iterative-solution" class="headerlink" title="iterative solution"></a>iterative solution</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> value;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">while</span>(root)</span><br><span class="line">       &#123;</span><br><span class="line">           value = root-&gt;val;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (p-&gt;val &lt; value &amp;&amp; q-&gt;val &lt; value)</span><br><span class="line">               root = root-&gt;left;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val &gt; value &amp;&amp; q-&gt;val &gt; value)</span><br><span class="line">               root = root-&gt;right;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">return</span> root;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

    </article>
    <!-- license  -->
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2018/10/14/Code-Implementation/" title= "Code Implementation">
                    <div class="nextTitle">Code Implementation</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2018/10/13/Algorithm-Lists/" title= "Algorithm Lists">
                    <div class="prevTitle">Algorithm Lists</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- LiveRe City install code -->
<div id="lv-container" data-id="city" data-uid="MTAyMC80MDE2Mi8xNjY4OQ==">
	<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
	</script>
<noscript> Please activate JavaScript for write a comment in LiveRe</noscript>
</div>
<!-- completed City install code -->

    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:linra.kura@gmail.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/sayakura" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:30vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Binary-Tree"><span class="toc-number">1.</span> <span class="toc-text">Binary Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LCA-Lowest-Common-Ancestor-In-a-Binary-Tree"><span class="toc-number">1.1.</span> <span class="toc-text">LCA(Lowest Common Ancestor) In a Binary Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Method-1-By-Storing-root-to-n1-and-root-to-n2-paths"><span class="toc-number">1.1.1.</span> <span class="toc-text">Method 1 (By Storing root to n1 and root to n2 paths):</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LCA-For-BST"><span class="toc-number">2.</span> <span class="toc-text">LCA For BST</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#recursive-solution"><span class="toc-number">2.1.</span> <span class="toc-text">recursive solution:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iterative-solution"><span class="toc-number">2.2.</span> <span class="toc-text">iterative solution</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 5
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/14</span><a class="archive-post-title" href= "/2018/10/14/Code-Implementation/" >Code Implementation</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/14</span><a class="archive-post-title" href= "/2018/10/14/Tree-Data-Structure-Note/" >Tree_Data_Structure_Note</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/13</span><a class="archive-post-title" href= "/2018/10/13/Algorithm-Lists/" >Algorithm Lists</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/09</span><a class="archive-post-title" href= "/2018/10/09/Dairy/" >Dairy</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/06</span><a class="archive-post-title" href= "/2018/10/06/Things-that-I-need-to-Learn/" >Things that I need to Learn</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="Algorithms"><span class="iconfont-archer">&#xe606;</span>Algorithms</span>
    
        <span class="sidebar-tag-name" data-tags="Code Note"><span class="iconfont-archer">&#xe606;</span>Code Note</span>
    
        <span class="sidebar-tag-name" data-tags="Notes"><span class="iconfont-archer">&#xe606;</span>Notes</span>
    
        <span class="sidebar-tag-name" data-tags="Personal"><span class="iconfont-archer">&#xe606;</span>Personal</span>
    
        <span class="sidebar-tag-name" data-tags="Data-Structure Note"><span class="iconfont-archer">&#xe606;</span>Data-Structure Note</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Kura Peng"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


